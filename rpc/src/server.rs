use super::interface::*;

use clap::Parser;
use futures::{future, prelude::*};
use std::{
    net::{IpAddr, Ipv6Addr, SocketAddr},
    time::Duration,
};
use tarpc::{
    context,
    server::{self, incoming::Incoming, Channel},
    tokio_serde::formats::Json,
};
use tokio::time;

#[derive(Clone)]
struct MutoolsRpcHandler(pub SocketAddr);

#[tarpc::server]
impl World for MutoolsRpcHandler {
    async fn get_version(self, _: context::Context) -> String {
	"0.1.0".into()
    }

    async fn get_num_project_descriptors(self, _: context::Context) -> usize {
	3
    }
}

pub struct MutoolsRpcServer {
    port: u16,
}

impl MutoolsRpcServer {

    pub fn new(port: u16) -> Self {
	Self {
	    port
	}
    }
    
    #[tokio::main(flavor = "current_thread")]
    pub async fn serve(self) -> anyhow::Result<()> {

	let server_addr = (IpAddr::V6(Ipv6Addr::LOCALHOST), self.port);

	// JSON transport is provided by the json_transport tarpc module. It makes it easy
	// to start up a serde-powered json serialization strategy over TCP.
	let mut listener = tarpc::serde_transport::tcp::listen(&server_addr, Json::default).await?;
	listener.config_mut().max_frame_length(usize::MAX);
	listener
        // Ignore accept errors.
            .filter_map(|r| future::ready(r.ok()))
            .map(server::BaseChannel::with_defaults)
        // Limit channels to 1 per IP.
            .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated World trait.
            .map(|channel| {
		let handler = MutoolsRpcHandler(channel.transport().peer_addr().unwrap());
		channel.execute(handler.serve())
            })
	// Max 10 channels.
            .buffer_unordered(10)
            .for_each(|_| async {})
	    .await;
	Ok(())
    }
}
    
