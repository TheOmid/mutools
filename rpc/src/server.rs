use super::interface::*;

use clap::Parser;
use futures::{future, prelude::*};
use std::{
    net::{IpAddr, Ipv6Addr, SocketAddr},
    time::Duration,
};
use tarpc::{
    context,
    server::{self, incoming::Incoming, Channel},
    tokio_serde::formats::Json,
};
use tokio::time;

#[derive(Clone)]
struct MutoolsRpcDispatcher {
    pub socket_address: SocketAddr,
    pub handler: std::sync::Arc<std::sync::Mutex<dyn MutoolsRpcHandler>>,
}

#[tarpc::server]
impl World for MutoolsRpcDispatcher {
    async fn get_version(self, c: context::Context) -> String {
	self.handler.lock().unwrap().get_version(c)
    }

    async fn init_transaction(self, c : context::Context) -> TransactionDescriptor {
	self.handler.lock().unwrap().init_transaction(c)
    }

    async fn commit_transaction(self, c : context::Context, transaction: TransactionDescriptor) -> () {
	self.handler.lock().unwrap().commit_transaction(c, transaction)
    }
    
    async fn get_project_descriptors(self, c : context::Context) -> Vec<ProjectDescriptor> {
	self.handler.lock().unwrap().get_project_descriptors(c)
    }

    async fn get_sound_descriptors(self, c: context::Context, project: ProjectDescriptor) -> Vec<SoundDescriptor> {
	self.handler.lock().unwrap().get_sound_descriptors(c, project)
    }
    
    async fn get_buffer_descriptors(self, c: context::Context, sound: SoundDescriptor) -> Vec<BufferDescriptor> {
	self.handler.lock().unwrap().get_buffer_descriptors(c, sound)
    }
}

pub struct MutoolsRpcServer {
    port: u16,
}

impl MutoolsRpcServer {

    pub fn new(port: u16) -> Self {
	Self {
	    port,
	}
    }
    
    #[tokio::main(flavor = "current_thread")]
    pub async fn serve(self, handler: std::sync::Arc<std::sync::Mutex<dyn MutoolsRpcHandler>>) -> anyhow::Result<()> {

	let server_addr = (IpAddr::V6(Ipv6Addr::LOCALHOST), self.port);

	// JSON transport is provided by the json_transport tarpc module. It makes it easy
	// to start up a serde-powered json serialization strategy over TCP.
	let mut listener = tarpc::serde_transport::tcp::listen(&server_addr, Json::default).await?;
	listener.config_mut().max_frame_length(usize::MAX);
	listener
        // Ignore accept errors.
            .filter_map(|r| future::ready(r.ok()))
            .map(server::BaseChannel::with_defaults)
        // Limit channels to 1 per IP.
            .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated World trait.
            .map(|channel| {
		let handler = MutoolsRpcDispatcher {
		    socket_address: channel.transport().peer_addr().unwrap(),
		    handler: handler.clone(),
		};
		channel.execute(handler.serve())
            })
	// Max 10 channels.
            .buffer_unordered(10)
            .for_each(|_| async {})
	    .await;
	Ok(())
    }
}
    
